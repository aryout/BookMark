####  高并发事务解决之道
1. 悲观锁 - 数据库表锁或行锁
2. 乐观锁 - 版本控制
3. 同步锁 - 单线程
4. Actor模型 - 行为消息队列（适用跨节点、分布式、高并发）
* 同步锁是单一JVM内的，对于分布式系统多个 Tomcat容器多个JVM，Actor模型能更好地“锁”好资源。
#### Callback

#### Actor[erlang]

Actors属于并发组件模型 ，通过组件方式定义并发编程范式的高级阶段，避免使用者直接接触多线程并发或线程池等基础概念。<br>
AKKA和Reactor两者皆是异步事件驱动框架，都构建自Actor模型

传统多数流行的语言并发是基于多线程之间的共享内存，使用同步方法防止写争夺，
Actors使用消息模型，每个Actors在同一时间处理最多一个消息，可以发送消息给其他Actors，
保证了单独写原则 。从而巧妙避免了多线程写争夺。

###### 介绍
1. [actor 模型原理](https://blog.csdn.net/tracymkgld/article/details/53814385)<br>
    Actor模型=数据+行为+消息

    一个Actor指的是一个最基本的计算单元。它能接收一个消息并且基于其执行计算。

    Actor模型内部的状态由自己的行为维护，外部线程不能直接调用对象的行为，必须通过消息才能激发行为，这样就保证Actor内部数据只有被自己修改。

    Actors一大重要特征在于actors之间相互隔离，它们并不互相共享内存。这点区别于对象。

2. [actor角色](https://blog.csdn.net/tracymkgld/article/details/53816492#comments)<br>

3. [actor模型是高并发事务的终极解决方案](https://www.jdon.com/45728)<br>
    只有有事务要求和没有事务要求，没有事务要求不高的说法，尽量缩短事务边界<br>
    有事务要求就要用事务机制，用了事务机制(数据喂机器的方式)+高并发就会出现死锁<br>
    Actor前提是事务+高并发<br>
    Actor模型和STM软事务比较也应该适用不同，软事务也是一种数据喂机器的方式<br>
    只要是数据喂机器的思维方式，就没有考虑到数据自身的逻辑一致性，也就不会想到要用行为保证其一致性，见：[领域模型的行为设计](https://www.jdon.com/45347)<br>

4. [actor模型的应用场景](https://www.jdon.com/45516)<br>

5. [一份关于AKKA的初步的琐碎的笔记](https://blog.csdn.net/bluishglc/article/details/52922459)<br>
###### AkkA[Scala]
###### Reactor[Spring]

#### CSP[golang]
###### [CSP和Actor的区别](https://blog.csdn.net/hotdust/article/details/72475630)
1. 关于消息发送方和接收方<br>
  * Actor：注重的处理单元，也就是Actor，而不是消息传送方式。发送消息时，都需要知道对方是谁（地址）
  * CSP：注重的是消息传送方式（channel），不关心发送的人和接收的人是谁

2. 消息传输方式<br>
  * Actor：每一对Actor之间，都有且只有一个“MailBox”来进行收发消息。无论什么类型消息都可以传输，所以要做好模式配置。消息的收发是异步的。
  * CSP：使用定义的 channel 进行收发消息。消息的收发是同步的（也可以做成异步的，但是一个有限异步）。每个channel是类型绑定的，只能传输这种类型信息。两个对象可以使用多个channel传输消息

3. 理念<br>
  * CSP的模式比较适合Boss-Worker模式的任务分发机制，它的侵入性没那么强，可以在现有的系统中通过CSP解决某个具体的问题。它并不试图解决通信的超时容错问题，这个还是需要发起方进行处理。同时由于Channel是显式的，虽然可以通过netchan（原来Go提供的netchan机制由于过于复杂，被废弃，在讨论新的netchan）实现远程Channel，但很难做到对使用方透明。 

  * 而Actor则是一种全新的抽象，使用Actor要面临整个应用架构机制和思维方式的变更。它试图要解决的问题要更广一些，比如

[^容错]: 我们有个supervisor，实际上它只是另一个process（所有东西都是actor），当被监控的process挂了，supervisor这个process会被通知并对此进行处理。这就让我们能创建「自愈」系统了。

  ，比如

[^分布式]: actor模型的有趣方面是它并不在意消息发送到的actor是本地的或者是另外节点上的

  。但Actor的问题在于以当前的调度效率，哪怕是用Goroutine这样的机制，也很难达到直接方法调用的效率。当前要像OO的『一切皆对象』一样实现一个『一切皆Actor』的语言，效率上肯定有问题。所以**折中的方式是在OO的基础上，将系统的某个层面的组件抽象为Actor**